from __future__ import annotations
import concurrent.futures
import threading
import time
import random
import queue
from datetime import datetime
from abc import ABC, abstractmethod
from typing import Optional, List
from faker import Faker
import mysql.connector


class Handler(ABC):
    @abstractmethod
    def set_next(self, handler: Handler) -> Handler:
        pass

    @abstractmethod
    def handle(self, request) -> Optional[str]:
        pass


class AbstractHandler(Handler):
    _next_handler: Optional[Handler] = None

    def set_next(self, handler: Handler) -> Handler:
        self._next_handler = handler
        return handler

    @abstractmethod
    def handle(self, customer: Customer) -> Optional[str]:
        if self._next_handler:
            return self._next_handler.handle(customer)
        return None


class Customer:
    id_counter = 0  # Static variable to track the last assigned ID

    def __init__(self, customer_id):
        Customer.id_counter += 1
        self.id = Customer.id_counter
        self.priority_queue = False if random.random() < 0.7 else True  # 70% chance to be a normal customer
        self.spending_money = random.randint(5, 20)  # Random spending money for the shop
        self.ticket_type = None  # Initialize ticket type as None


class Cashier:
    def __init__(self):
        self.num_normal_tickets_sold = 0
        self.num_priority_tickets_sold = 0

    def sell_ticket(self, customer: Customer, ticket_type: str):
        try:
            if ticket_type == "Normal":
                self.num_normal_tickets_sold += 1
                customer.ticket_type = ticket_type
                print(f"Customer {customer.id} bought a regular ticket.")
            elif ticket_type == "Priority":
                self.num_priority_tickets_sold += 1
                customer.ticket_type = ticket_type
                print(f"Customer {customer.id} bought a priority ticket.")
            else:
                raise ValueError("Invalid ticket type. Must be 'Normal' or 'Priority'.")
        except ValueError as ve:
            print("Error selling ticket:", ve)


class Attraction(AbstractHandler):
    def __init__(self, capacity: int, duration: int):
        super().__init__()
        self.capacity = capacity
        self.current_capacity = 0
        self.lock = threading.Lock()
        self.duration = duration
        self.normal_price = 10
        self.entry_time = 0
        self.exit_time = 0
        self.priority_price = 25
        self.visits_count = 0  # Count of visits to this attraction
        self.total_normal_clients = 0  # Total normal clients visited
        self.total_priority_clients = 0  # Total priority clients visited
        self.total_normal_profit = 0.0  # Total profit from normal clients
        self.total_priority_profit = 0.0  # Total profit from priority clients
        self.priority_queue = queue.Queue()
        self.normal_queue = queue.Queue()

    def process_customer(self, customer: Customer):
        customer_type = "Priority" if customer.priority_queue else "Normal"
        ticket_price = self.priority_price if customer.priority_queue else self.normal_price
        with self.lock:
            if self.current_capacity < self.capacity:
                self.current_capacity += 1
                self.visits_count += 1
                if customer.priority_queue:
                    self.total_priority_clients += 1
                else:
                    self.total_normal_clients += 1
            else:
                print(f"{self.__class__.__name__} is full. Please wait until the session is over...")
                return "Capacity full"

        self.entry_time = time.time()
        entry_time_str = datetime.fromtimestamp(self.entry_time).strftime('%Y-%m-%d %H:%M:%S')
        print(f"{customer_type} customer {customer.id} entered the {self.__class__.__name__} at {entry_time_str}")

        time.sleep(self.duration)  # Simulate the customer's visit

        self.exit_time = time.time()
        exit_time_str = datetime.fromtimestamp(self.exit_time).strftime('%Y-%m-%d %H:%M:%S')
        print(f"{customer_type} customer {customer.id} left the {self.__class__.__name__} at {exit_time_str}")

    def handle(self, customer: Customer) -> str:
        try:
            queue_used = self.priority_queue if customer.priority_queue else self.normal_queue
            queue_used.put(customer)

            # Check if there are priority customers waiting
            if not self.priority_queue.empty():
                while not self.priority_queue.empty():
                    priority_customer = self.priority_queue.get()
                    self.process_customer(priority_customer)
            else:
                # If no priority customers waiting, process normal customers
                while not self.normal_queue.empty():
                    normal_customer = self.normal_queue.get()
                    self.process_customer(normal_customer)
        except Exception as e:
            print("Error handling customer:", e)
            return "Error handling customer"
        return super().handle(customer)


class WaterPark(Attraction):
    def __init__(self):
        super().__init__(capacity=10, duration=6)
        self.name = "WaterPark"


class RollerCoaster(Attraction):
    def __init__(self):
        super().__init__(capacity=3, duration=3)
        self.name = "RollerCoaster"


class Shop(Attraction):
    def __init__(self):
        super().__init__(capacity=8, duration=7)
        self.total_sales = 0  # To track additional spending in the shop
        self.name = "Shop"

    def process_customer(self, customer: Customer):
        try:
            super().process_customer(customer)
            additional_spending = customer.spending_money
            with self.lock:
                self.total_sales += additional_spending
            print(f"Customer {customer.id} spent an additional ${additional_spending:.2f} in the shop.")
        except Exception as e:
            print("Error processing customer in Shop:", e)


class FoodTruck(Attraction):
    def __init__(self):
        super().__init__(capacity=5, duration=2)
        self.food_price = 5  # Flat rate for simplicity
        self.name = "FoodTruck"

    def process_customer(self, customer: Customer):
        try:
            super().process_customer(customer)
            with self.lock:
                self.total_normal_profit += self.food_price
                self.total_normal_clients += 1
            print(f"Customer {customer.id} bought food for ${self.food_price:.2f}.")
        except Exception as e:
            print("Error processing customer in FoodTruck:", e)


class FerrisWheel(Attraction):
    def __init__(self):
        super().__init__(capacity=6, duration=8)
        self.name = "FerrisWheel"


class ArcadeGames(Attraction):
    def __init__(self):
        super().__init__(capacity=4, duration=5)
        self.name = "ArcadeGames"


class CircusShow(Attraction):
    def __init__(self):
        super().__init__(capacity=15, duration=10)
        self.name = "CircusShow"

def simulate_park_visit(attractions: List[Attraction], customer: Customer, cashier: Cashier):
    try:
        # Determine how many attractions the customer will visit
        num_attractions_to_visit = random.randint(1, len(attractions))

        # Randomly select attractions for the customer to visit
        attractions_to_visit = random.sample(attractions, num_attractions_to_visit)

        # Visit the cashier to buy a ticket
        ticket_type = "Normal" if not customer.priority_queue else "Priority"
        cashier.sell_ticket(customer, ticket_type)  # Use the cashier instance

        # Visit selected attractions
        for attraction in attractions_to_visit:
            attraction.handle(customer)
    except Exception as e:
        print("Error during park visit simulation:", e)


if __name__ == "__main__":
    try:
        # Create cashier instance
        cashier = Cashier()

        num_customers = 20

        # Create attractions and customers
        attractions = [WaterPark(), RollerCoaster(), Shop(), FerrisWheel(), ArcadeGames(), CircusShow(), FoodTruck()]
        customer_db = CustomerDatabase()
        customers = customer_db.generate_customers(num_customers)

        # Simulate park visits
        with concurrent.futures.ThreadPoolExecutor() as executor:
            for customer in customers:
                executor.submit(simulate_park_visit, attractions, customer, cashier)

        # Wait for all threads to complete
        executor.shutdown()

        # Calculate and print summary statistics
        total_normal_clients = cashier.num_normal_tickets_sold
        total_priority_clients = cashier.num_priority_tickets_sold
        total_normal_profit = cashier.num_normal_tickets_sold * attractions[0].normal_price
        total_priority_profit = cashier.num_priority_tickets_sold * attractions[0].priority_price
        shop_sales = next((attr.total_sales for attr in attractions if isinstance(attr, Shop)), 0)
        total_park_profit = total_normal_profit + total_priority_profit + shop_sales

        print("\nSummary:::")
        print(f"Total normal clients: {total_normal_clients}")
        print(f"Total priority clients: {total_priority_clients}")
        print(f"Total normal profit: ${total_normal_profit:.2f}")
        print(f"Total priority profit: ${total_priority_profit:.2f}")
        print(f"Total shop sales: ${shop_sales:.2f}")
        print(f"Total park profit: ${total_park_profit:.2f}")

        # Determine the most visited attraction
        print("\nCalculating most visited attraction")
        most_visited = max(attractions, key=lambda x: x.visits_count, default=None)
        if most_visited:
            print(
                f"{most_visited.__class__.__name__} is the most visited attraction with {most_visited.visits_count} visits.")

        # Connect to MySQL database and insert data
        cnx = mysql.connector.connect(user='root', password='Lehe05547407', host='127.0.0.1', database='example')
        cursor = cnx.cursor()

        cursor.execute("""
            CREATE TABLE IF NOT EXISTS Attraction (
                id INT AUTO_INCREMENT PRIMARY KEY,
                name VARCHAR(255) NOT NULL,
                capacity INT NOT NULL,
                duration FLOAT NOT NULL,
                total_normal_clients INT NOT NULL,
                total_priority_clients INT NOT NULL,
                total_normal_profit DECIMAL(10, 2) NOT NULL,
                total_priority_profit DECIMAL(10, 2) NOT NULL,
                visits_count INT NOT NULL
            );
        """)

        # Insert attraction data into the Attraction table
        attractions_data = []
        for attraction in attractions:
            attraction_data = (
                attraction.name,
                attraction.capacity,
                attraction.duration,
                attraction.total_normal_clients,
                attraction.total_priority_clients,
                attraction.total_normal_profit,
                attraction.total_priority_profit,
                attraction.visits_count
            )
            attractions_data.append(attraction_data)

        cursor.executemany("""
            INSERT INTO Attraction (name, capacity, duration, total_normal_clients, total_priority_clients, total_normal_profit, total_priority_profit, visits_count) 
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """, attractions_data)

        # Create Customer table if not exists
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS Customer (
                customer_id VARCHAR(255) NOT NULL,
                priority_queue BOOLEAN NOT NULL,
                spending_money DECIMAL(10, 2) NOT NULL
            );
        """)

        # Insert customer data into the Customer table
        customers_data = []
        for customer in customers:
            customer_data = (
                customer.id,
                customer.priority_queue,
                customer.spending_money
            )
            customers_data.append(customer_data)

        cursor.executemany("""
            INSERT INTO Customer (customer_id, priority_queue, spending_money) 
            VALUES (%s, %s, %s)
        """, customers_data)

        # Commit changes and close connection
        cnx.commit()
        cursor.close()
        cnx.close()
    except mysql.connector.Error as err:
        print("MySQL Error:", err)
    except Exception as e:
        print("An error occurred:", e)
#%%
